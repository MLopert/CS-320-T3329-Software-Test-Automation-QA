# CS-320-T3329-Software-Test-Automation-QA

This Software Test Automation QA course gave me insight into how to ensure my code is being properly tested. Using JUnit, I could test each functionality declared in my code and use its coverage tool to see if anything was left unchecked. When coverage is run on a JUnit test class, any areas left unchecked will be marked red. The tool will also give me a percentage that shows how much of the class I am testing has been covered. This is an incredibly helpful tool as it helps to verify that my requirements are working as expected on a detailed level. This tool along with maintaining standards and practices to ensure reliability and security during development can help better protect a company from experiencing downfalls when they go live. 

In this course, we looked over multiple events in the past that were affected by software errors. Some of these include the explosion of Ariane 5, the Chinook helicopter crash, and the Hitomi satellite. These events, along with many others, had negative impacts like death, financial loss, and misdirected blame. It is important as a developer to realize the effect I have on my consumer if I don't take responsibility for properly testing my code and resolving defects when they are recognized. 

In each project, there will be a requirement-gathering process. At this point, it is important to understand fully what the clients are looking for. Once that is understood, it is up to us on the development team to see if that can be achieved and if it cannot if there are any potential alternatives. The team's understanding of the requirements will be communicated and approved by the client's team before development. Without that approval and/or confirmation, it can be problematic to assume and start development. Using finalized requirements, you can start development and add in error handling where false input is expected. 

The design stage occurs after requirements are finalized. Each requirement must be fully understood. As a developer, we must take a step back and think about how each requirement will play into one another, how they can be achieved, their similarities, and their differences. Once that has been done, an approach can be selected to fulfill that requirement. 
